Primeniramente foi provados um lema trivial sobre c_bubbling preservar o tamanho da lista .
Para este fim é usada a indução forte baseada no tamanho da lista visto que bubbling possui uma estrutura recursiva cuja condição de parada e a lista nula.
Para evitar problemas futuros são descartados os casos da lista vazia e da lista unitaria l=null e cdr(l)= null ao assumir que a lista ja assumiu esses valores.Em seguida a função é dividida em 3 casos criados a partir de sua propria definição onde 1 deles (cont=0) pode ser automaticamente dado come verdadeiro ao ser aplicada a função, e os outros 2 devem ser provados usando-se a hipotese de indução que é instanciada com os parametros da recursão do c_bubbling em cada um dos casos gerando assim provas triviais onde x = y -> 1+x = 1+y.

Em seguida é provado que c_bubbling e bubbling retornam a mesma lista caso tenham os mesmos parametros usando a mesma logica da prova anterior.

O proximo lema provado foi a equivalencia de bubblesort_aux e c_bubblesort_aux para tanto é realizada uma indução no segundo parametor de bubblesort aux um contador que vai de length-1 até 0, esta indução deve ser feita neste parametro pois ele é a condição de parada do algoritmo, a pela definição c_bubbessort_aux
e bubblesort_aux são divididos nos mesmos cados e 1 desses casos pode ser automaticamente aprovadocomo verdadeiro por ser definido um valor fixo com uma verdade trivial o outro cos gera uma estrutura recursiva onde as funções bubblesort_aux e c_bubblesort_aux são chamadas com os parametos bubbling e c_bubbling, para continuar a prova é instanciada a hipotese de indução como os parametros de bubblesort aux e é chamado o lema da equivalencia entre c_bubbing e bubbling gerando uma verdade trivial a=b  ^ x(a, c)= y(a,c) -> a(a,c)=y(b,c).

O proximo lema provado foi o lema com o custo do c_bubbling este lema foi provado de forma identica aos outos 2 lemas relacionados unicamente a c_bubbling.

os dois lemas seguintes bubblesort_aux_list_dont_change_number(lema que prova que quaisquer listas de tamanhos identicos terão o mesmo numero de retorno com o c_bubblesort_aux) e c_bubblesort_aux_sum_quadratic (lema que prova que o numero retornado pelo c_bubblesort_aux sempre será o resultado do somatorio de 1 a n onde n é o valor do segundo parâmetro) usaram a indução forte de uma dorma diferente das outras provas nesta indução foi ultilizado um "case" pois ela é voltada para o segundo parâmetro e este parametro não pode ser negativo então para que o caso onde a indução é falsa nunca ocorra foi usado este "case" que remove a possibilidade do parametro inserido na hipotese de indução ser negativo.